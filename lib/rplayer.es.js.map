{"version":3,"file":"rplayer.es.js","sources":["../src/lib/playHls.ts","../src/lib/playM3u.ts","../src/lib/index.ts"],"sourcesContent":["// Interface pour les statistiques de lecture HLS\nexport interface HlsStats {\n  bandwidth: number;        // Estimation du débit en bits par seconde\n  droppedFrames: number;    // Nombre d'images perdues\n  bufferLength: number;     // Longueur du tampon en secondes\n  currentLevel: number;     // Niveau de qualité actuel\n  totalLevels: number;      // Nombre total de niveaux de qualité disponibles\n  loadLatency: number;      // Latence de chargement en millisecondes\n}\n\n// Type pour les callbacks de statistiques\nexport type StatsCallback = (stats: HlsStats) => void;\n\n/**\n * Play or load the provided HLS source with dynamic loading of hls.js if needed.\n * @param {HTMLAudioElement} audioElement - The audio element to play the HLS stream.\n * @param {string} src - The source URL of the HLS stream.\n * @param {StatsCallback} [onStatsUpdate] - Optional callback function for streaming statistics updates\n * @param {boolean} [autoplay=true] - Whether to start playback automatically\n * @returns {Promise<any|null>} - The Hls instance if created, or null if native HLS is used\n */\nexport async function playHls(\n  audioElement: HTMLAudioElement,\n  src: string,\n  onStatsUpdate?: StatsCallback,\n  autoplay: boolean = true\n): Promise<any | null> {\n  // First check if we can use native HLS support (Safari/iOS)\n  if (audioElement.canPlayType('application/vnd.apple.mpegurl')) {\n    console.log('Using native HLS support');\n    audioElement.src = src;\n\n    return new Promise((resolve) => {\n      audioElement.addEventListener('loadedmetadata', () => {\n        if (autoplay) {\n          const playPromise = audioElement.play();\n\n          if (playPromise !== undefined) {\n            playPromise.catch(error => {\n              console.warn('Auto-play was prevented, user interaction may be needed', error);\n            });\n          }\n        }\n\n        resolve(null); // Return null as we're using native HLS support\n      }, { once: true });\n    });\n  }\n\n  // Otherwise, try to dynamically import hls.js\n  try {\n    const { default: Hls } = await import('hls.js');\n\n    // If HLS.js is supported, use it\n    if (Hls.isSupported()) {\n      // Create a new HLS instance with improved error recovery\n      const hls = new Hls({\n        // Add some configuration for better performance and reliability\n        maxBufferLength: 30,\n        maxMaxBufferLength: 60,\n        liveSyncDurationCount: 3,\n        enableWorker: true,\n        lowLatencyMode: true,\n        // Error recovery settings\n        fragLoadingMaxRetry: 5,\n        manifestLoadingMaxRetry: 5,\n        levelLoadingMaxRetry: 5\n      });\n\n      // Setup error handling\n      hls.on(Hls.Events.ERROR, (event, data) => {\n        if (data.fatal) {\n          switch (data.type) {\n            case Hls.ErrorTypes.NETWORK_ERROR:\n              // Try to recover network error\n              console.warn('Network error encountered, trying to recover', data);\n              hls.startLoad();\n              break;\n            case Hls.ErrorTypes.MEDIA_ERROR:\n              // Try to recover media error\n              console.warn('Media error encountered, trying to recover', data);\n              hls.recoverMediaError();\n              break;\n            default:\n              // Cannot recover from other fatal errors\n              console.error('Fatal error encountered, cannot recover', data);\n              break;\n          }\n        }\n      });\n\n      // Set up stats monitoring if callback is provided\n      if (onStatsUpdate) {\n        const statsInterval = 3000; // Update stats every 3 seconds\n        const statsTimer = setInterval(() => {\n          if (hls) {\n            // Calculate buffer length\n            let bufferLength = 0;\n            if (hls.media && hls.media.buffered.length > 0) {\n              bufferLength = hls.media.buffered.end(hls.media.buffered.length - 1) - hls.media.currentTime;\n            }\n\n            const hlsStats: HlsStats = {\n              bandwidth: hls.bandwidthEstimate,\n              droppedFrames: 0, // Need to calculate from media element if needed\n              bufferLength: bufferLength,\n              currentLevel: hls.currentLevel,\n              totalLevels: hls.levels ? hls.levels.length : 0,\n              loadLatency: 0  // Hls.js v1.6.1 doesn't expose this directly through typed properties\n            };\n\n            onStatsUpdate(hlsStats);\n          }\n        }, statsInterval);\n\n        // Clean up the timer when media is detached\n        hls.on(Hls.Events.MEDIA_DETACHING, () => {\n          clearInterval(statsTimer);\n        });\n      }\n\n      // Load the source and attach to audio element\n      hls.loadSource(src);\n      hls.attachMedia(audioElement as HTMLVideoElement);\n\n      // Start playback when manifest is parsed (if autoplay is enabled)\n      hls.on(Hls.Events.MANIFEST_PARSED, () => {\n        if (autoplay) {\n          const playPromise = audioElement.play();\n\n          if (playPromise !== undefined) {\n            playPromise.catch(error => {\n              console.warn('Auto-play was prevented, user interaction may be needed', error);\n            });\n          }\n        }\n      });\n\n      return hls;\n    } else {\n      throw new Error('HLS.js is not supported in this browser');\n    }\n  } catch (error) {\n    console.error('Failed to load or initialize hls.js:', error);\n    throw new Error('Failed to load or initialize HLS support: ' + (error instanceof Error ? error.message : String(error)));\n  }\n}\n\n","import { playHls } from './playHls';\n\n/**\n * Interface for track information in M3U playlists\n */\nexport interface M3UTrackInfo {\n  url: string;\n  title: string;\n}\n\n/**\n * Function to process standard M3U playlists (non-HLS)\n * This function downloads and parses an M3U playlist\n * @param player - The RPlayer instance to use for playback\n * @param url - The URL of the M3U playlist\n * @returns Promise that resolves with the first track URL and title when playback starts or rejects on error\n */\nexport async function playM3u(player: HTMLAudioElement, url: string): Promise<string> {\n  try {\n    console.log(`Fetching M3U playlist from: ${url}`);\n\n    // Spécial pour les fichiers locaux (peut-être que l'URL est déjà un chemin local ou relatif)\n    if (!url.startsWith('http://') && !url.startsWith('https://')) {\n      // C'est une URL locale, construisons une URL absolue\n      const origin = window.location.origin;\n      // Gestion spéciale pour les chemins absolus et relatifs\n      if (url.startsWith('/')) {\n        url = origin + url;\n      } else {\n        // Pour les chemins relatifs comme './playlist.m3u' ou 'playlist.m3u'\n        url = origin + '/' + url.replace(/^\\.\\//, '');\n      }\n      console.log(`Local file detected, using absolute URL: ${url}`);\n    }\n\n    // Récupérer le contenu de la playlist avec un délai d'attente de 10 secondes\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000);\n\n    try {\n      // Ajout des options pour éviter les problèmes CORS\n      const response = await fetch(url, {\n        signal: controller.signal,\n        mode: 'cors',\n        credentials: 'same-origin'\n      });\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch M3U playlist: ${response.status}`);\n      }\n\n      const content = await response.text();\n      console.log(`M3U content fetched, size: ${content.length} bytes`);\n\n      // Parser le contenu de la playlist\n      const lines = content.split('\\n');\n      const mediaUrls: {url: string; title: string}[] = [];\n      let currentTitle = '';\n\n      // Extraire les URL des médias avec leurs titres\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n\n        // Ignorer les lignes vides\n        if (!line) continue;\n\n        // Traiter les métadonnées EXTINF (titres)\n        if (line.startsWith('#EXTINF:')) {\n          const titleMatch = line.match(/#EXTINF:.*,(.+)/);\n          if (titleMatch && titleMatch[1]) {\n            currentTitle = titleMatch[1].trim();\n          }\n          continue;\n        }\n\n        // Ignorer les autres commentaires et directives\n        if (line.startsWith('#')) continue;\n\n        // Si c'est une URL, l'ajouter avec son titre\n        // Vérifier si c'est une URL absolue ou relative\n        let mediaUrl = line;\n\n        // Si c'est une URL relative, la rendre absolue par rapport à l'URL de la playlist\n        if (!line.match(/^(https?:\\/\\/|rtmp:\\/\\/|rtsp:\\/\\/)/i)) {\n          try {\n            const baseUrl = new URL(url);\n            const resolvedUrl = new URL(line, baseUrl.href);\n            mediaUrl = resolvedUrl.href;\n          } catch (e) {\n            console.warn(`Could not resolve relative URL: ${line}`, e);\n          }\n        }\n\n        // Vérifier si l'URL semble être un flux audio (filtrer vidéo si possible)\n        // Ceci est une heuristique simple et pourrait ne pas être parfaite\n        const isLikelyAudio =\n          !mediaUrl.match(/\\.(m3u8|mp4|mkv|avi|mov|flv|wmv|ts)$/i) ||\n          mediaUrl.match(/\\.(mp3|aac|ogg|opus|wav|m4a)$/i) ||\n          mediaUrl.includes('audio') ||\n          !mediaUrl.includes('video');\n\n        if (isLikelyAudio) {\n          mediaUrls.push({\n            url: mediaUrl,\n            title: currentTitle || `Track ${mediaUrls.length + 1}`\n          });\n        }\n\n        // Réinitialiser le titre pour la prochaine entrée\n        currentTitle = '';\n      }\n\n      console.log(`Found ${mediaUrls.length} audio URLs in playlist`);\n\n      // Vérifier si des URL ont été trouvées\n      if (mediaUrls.length === 0) {\n        throw new Error('No audio URLs found in M3U playlist');\n      }\n\n      // Utiliser la première URL\n      const firstTrack = mediaUrls[0];\n      console.log(`Found first entry in M3U playlist: ${firstTrack.title} (${firstTrack.url})`);\n\n      // Store all tracks in a global variable to allow navigation between them later\n      if (typeof window !== 'undefined') {\n        (window as any).__currentM3UPlaylist = mediaUrls;\n        (window as any).__currentM3UIndex = 0;\n      }\n\n      // Store track title as a custom property on the audio element for MediaSession\n      if (player instanceof HTMLAudioElement) {\n        (player as any).__trackTitle = firstTrack.title || '';\n        (player as any).__trackSource = 'M3U Playlist';\n\n        // Update MediaSession if available\n        if ('mediaSession' in navigator) {\n          navigator.mediaSession.metadata = new MediaMetadata({\n            title: firstTrack.title || 'Unknown Track',\n            artist: 'RPlayer M3U',\n            album: 'M3U Playlist',\n            artwork: [\n              { src: '/images/favicon.png', sizes: '96x96', type: 'image/png' },\n              { src: '/images/icons-192.png', sizes: '192x192', type: 'image/png' }\n            ]\n          });\n        }\n      }\n\n      // Au lieu de jouer directement, nous renvoyons l'URL du premier élément\n      // pour que RPlayer puisse la traiter selon son type (HLS, MP3, etc.)\n      return firstTrack.url;\n    } catch (error) {\n      console.error('Error fetching M3U playlist:', error);\n      throw new Error(`Timeout or network error fetching playlist: ${error instanceof Error ? error.message : String(error)}`);\n    }\n\n  } catch (error) {\n    console.error('Error playing M3U playlist:', error);\n    throw new Error(`Failed to play M3U playlist: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n","import { playHls } from './playHls';\nimport { playM3u } from './playM3u';\n\n// Type definitions\nexport type PlaybackStatus = 'playing' | 'paused' | 'stopped';\n\n/**\n * RPlayer - An enhanced audio player with HLS support\n * @extends Audio\n */\nclass RPlayer extends Audio {\n  private hls: any | null = null;\n  private isHls: boolean = false;\n  private lastSrc: string = '';\n  private readonly errorHandlers: Array<(error: Error) => void> = [];\n  private readonly playbackHandlers: Array<(status: PlaybackStatus) => void> = [];\n\n  /**\n   * Creates a new RPlayer instance\n   * @param {string} [initialSource] - Optional initial audio source to play\n   */\n  constructor(initialSource?: string) {\n    super();\n\n    // Load volume from localStorage if available\n    this.initializeVolume();\n\n    // Set event listeners\n    this.setupEventListeners();\n\n    // Play initial source if provided after constructor finishes\n    if (initialSource) {\n      setTimeout(() => {\n        this.playSrc(initialSource).catch(error => {\n          console.error('Failed to play initial source:', error);\n        });\n      }, 0);\n    }\n  }\n\n  /**\n   * Initialize volume settings from localStorage\n   * @private\n   */\n  private initializeVolume(): void {\n    try {\n      const savedVolume = localStorage.getItem('RPlayer-volume');\n      if (savedVolume !== null) {\n        const volume = parseFloat(savedVolume);\n        if (!isNaN(volume) && volume >= 0 && volume <= 1) {\n          this.volume = volume;\n        }\n      }\n    } catch (error) {\n      console.warn('Could not retrieve volume settings from localStorage', error);\n    }\n  }\n\n  /**\n   * Set up event listeners for the audio element\n   * @private\n   */\n  private setupEventListeners(): void {\n    // Save volume to localStorage when changed\n    this.addEventListener('volumechange', () => {\n      try {\n        localStorage.setItem('RPlayer-volume', this.volume.toString());\n      } catch (error) {\n        console.warn('Could not save volume settings to localStorage', error);\n      }\n    });\n\n    // Handle errors\n    this.addEventListener('error', (event) => {\n      const error = new Error(`Media error: ${this.error?.code ?? 'unknown'}`);\n      this.errorHandlers.forEach(handler => handler(error));\n    });\n\n    // Track play/pause status\n    this.addEventListener('play', () => {\n      this.playbackHandlers.forEach(handler => handler('playing'));\n    });\n\n    this.addEventListener('pause', () => {\n      this.playbackHandlers.forEach(handler => handler('paused'));\n    });\n  }\n\n  /**\n   * Validate if the provided URL is an HLS stream.\n   * @param {string | URL} url - The URL to validate.\n   * @returns {boolean} True if the URL is an HLS stream, false otherwise.\n   * @private\n   */\n  private isHlsUrl(url: string | URL): boolean {\n    const urlStr = url.toString();\n\n    // Gestion simple pour les chemins relatifs ou les URL\n    if (urlStr.endsWith('.m3u8')) {\n      return true;\n    }\n\n    try {\n      // Pour les URL complètes, nous pouvons toujours utiliser l'objet URL\n      if (urlStr.startsWith('http://') || urlStr.startsWith('https://')) {\n        const parsedUrl = new URL(urlStr);\n        return parsedUrl.pathname.endsWith('.m3u8');\n      }\n      return false;\n    } catch (error) {\n      // Si nous ne pouvons pas construire un objet URL, vérifier simplement l'extension\n      console.warn('URL parsing failed in isHlsUrl, using fallback check:', urlStr);\n      return false;\n    }\n  }\n\n  /**\n   * Validate if the provided URL is a standard M3U playlist.\n   * @param {string | URL} url - The URL to validate.\n   * @returns {boolean} True if the URL is a standard M3U playlist, false otherwise.\n   * @private\n   */\n  private isM3uUrl(url: string | URL): boolean {\n    const urlStr = url.toString();\n\n    // Gestion simple pour les chemins relatifs ou les URL\n    if (urlStr.endsWith('.m3u') && !urlStr.endsWith('.m3u8')) {\n      return true;\n    }\n\n    try {\n      // Pour les URL complètes, nous pouvons toujours utiliser l'objet URL\n      if (urlStr.startsWith('http://') || urlStr.startsWith('https://')) {\n        const parsedUrl = new URL(urlStr);\n        return parsedUrl.pathname.endsWith('.m3u') && !parsedUrl.pathname.endsWith('.m3u8');\n      }\n      return false;\n    } catch (error) {\n      // Si nous ne pouvons pas construire un objet URL, vérifier simplement l'extension\n      console.warn('URL parsing failed in isM3uUrl, using fallback check:', urlStr);\n      return false;\n    }\n  }\n\n  /**\n   * Check if the current device is an iOS device.\n   * @returns {boolean} True if the current device is an iOS device, false otherwise.\n   * @readonly\n   */\n  get isIOS(): boolean {\n    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n  }\n\n  /**\n   * Validate if the current source is an HLS stream.\n   * @returns {boolean} True if the current source is an HLS stream, false otherwise.\n   * @readonly\n   */\n  get isHlsjs(): boolean {\n    return this.isHls;\n  }\n\n  /**\n   * Check if the audio element is currently playing.\n   * @returns {boolean} True if the audio element is playing, false otherwise.\n   * @readonly\n   */\n  get isPlaying(): boolean {\n    return !this.paused;\n  }\n\n  /**\n   * Get the current source URL of the audio element.\n   * @returns {string} The current source URL of the audio element.\n   * @readonly\n   */\n  get url(): string {\n    return this.lastSrc;\n  }\n\n  /**\n   * Register a handler for playback status changes\n   * @param {function} handler - The function to call when playback status changes\n   */\n  onPlaybackStatusChange(handler: (status: 'playing' | 'paused' | 'stopped') => void): void {\n    this.playbackHandlers.push(handler);\n  }\n\n  /**\n   * Register a handler for errors\n   * @param {function} handler - The function to call when an error occurs\n   */\n  onError(handler: (error: Error) => void): void {\n    this.errorHandlers.push(handler);\n  }\n\n  /**\n   * Remove a previously registered playback status handler\n   * @param {function} handler - The handler to remove\n   */\n  removePlaybackStatusHandler(handler: (status: 'playing' | 'paused' | 'stopped') => void): void {\n    const index = this.playbackHandlers.indexOf(handler);\n    if (index !== -1) {\n      this.playbackHandlers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Remove a previously registered error handler\n   * @param {function} handler - The handler to remove\n   */\n  removeErrorHandler(handler: (error: Error) => void): void {\n    const index = this.errorHandlers.indexOf(handler);\n    if (index !== -1) {\n      this.errorHandlers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Play the provided audio source\n   * @param {string} src - The source URL of the audio stream\n   * @returns {Promise<void>} - A promise that resolves when playback has started or rejects on error\n   */\n  async playSrc(src: string): Promise<void> {\n    console.log(`[RPlayer] playSrc appelé avec: ${src}`);\n\n    // Convertir les chemins relatifs en URL absolues\n    if (src.startsWith('/') && !src.startsWith('//') && typeof window !== 'undefined') {\n      const origin = window.location.origin;\n      src = `${origin}${src}`;\n      console.log(`[RPlayer] URL relative convertie en absolue: ${src}`);\n    }\n\n    // Don't reload if it's the same source and just paused\n    if (this.lastSrc === src && this.paused && this.currentTime > 0) {\n      try {\n        console.log(`[RPlayer] Même source détectée, reprise de la lecture: ${src}`);\n        await this.play();\n        return;\n      } catch (error) {\n        // If there's an error playing, try to reload the source\n        console.warn('[RPlayer] Erreur lors de la reprise de la lecture, tentative de rechargement', error);\n      }\n    }\n\n    try {\n      // Stop any current playback\n      this.stop();\n\n      // Déterminer le type de source\n      const isHls = this.isHlsUrl(src);\n      const isM3u = this.isM3uUrl(src);\n      console.log(`[RPlayer] Type de source: ${isHls ? 'HLS' : isM3u ? 'M3U standard' : 'Direct'}`);\n\n      // Détermination du type de source pour le log\n      let sourceType = 'Direct';\n      if (isHls) sourceType = 'HLS';\n      else if (isM3u) sourceType = 'M3U standard';\n      console.log(`[RPlayer] Type de source: ${sourceType}`);\n\n      if (isHls) {\n        try {\n          // playHls est désormais asynchrone et retourne une promesse\n          const hlsInstance = await playHls(this, src);\n          this.hls = hlsInstance;\n          this.lastSrc = src;\n          this.isHls = true;\n\n          // Return a promise that resolves when playback starts or rejects on error\n          return new Promise((resolve, reject) => {\n            const onPlay = () => {\n              this.removeEventListener('playing', onPlay);\n              this.removeEventListener('error', onError);\n              resolve();\n            };\n\n            const onError = () => {\n              this.removeEventListener('playing', onPlay);\n              this.removeEventListener('error', onError);\n              reject(new Error(`Failed to load HLS source: ${src}`));\n            };\n\n            // Si playHls a déjà commencé la lecture (support natif), résoudre immédiatement\n            if (!this.paused) {\n              resolve();\n            } else {\n              this.addEventListener('playing', onPlay);\n              this.addEventListener('error', onError);\n            }\n          });\n        } catch (error) {\n          console.error('Error initializing HLS playback:', error);\n          throw error;\n        }\n      }      else if (this.isM3uUrl(src)) {\n        try {\n          console.log(`[RPlayer] Attempting to play M3U standard playlist: ${src}`);\n          // For standard .m3u files\n          // playM3u now returns the URL of the first item in the playlist\n          const mediaUrl = await playM3u(this, src);\n          console.log(`[RPlayer] URL extracted from M3U playlist: ${mediaUrl}`);\n\n          // Call playSrc recursively with the media URL\n          // This allows automatic handling of HLS streams\n          if (mediaUrl === src) {\n            // Avoid an infinite loop if the URL is the same\n            throw new Error(\"The URL extracted from the playlist is identical to the playlist URL\");\n          }\n\n          // Update for traceability\n          this.lastSrc = src; // Keep the playlist URL as the original source\n\n          // Update MediaSession if available\n          if ('mediaSession' in navigator && navigator.mediaSession) {\n            // Try to extract station name from the URL path\n            let title = \"Radio Station\";\n            try {\n              // Extract file name from URL and clean it up\n              const urlObj = new URL(mediaUrl);\n              const pathParts = urlObj.pathname.split('/');\n              const fileName = pathParts[pathParts.length - 1];\n              if (fileName) {\n                // Remove extension and replace underscores/hyphens with spaces\n                title = fileName.replace(/\\.(mp3|aac|ogg|m4a|wav)$/i, '')\n                               .replace(/[_-]/g, ' ');\n              }\n            } catch (e) {\n              console.warn('Failed to extract title from URL:', e);\n            }\n\n            navigator.mediaSession.metadata = new MediaMetadata({\n              title: title,\n              artist: 'RPlayer M3U',\n              album: 'M3U Playlist',\n              artwork: [\n                { src: '/images/favicon.png', sizes: '96x96', type: 'image/png' },\n                { src: '/images/icons-192.png', sizes: '192x192', type: 'image/png' }\n              ]\n            });\n          }\n\n          // Redirect to the media URL\n          console.log(`[RPlayer] Redirecting to: ${mediaUrl}`);\n          return this.playSrc(mediaUrl);\n        } catch (error) {\n          console.error('[RPlayer] Erreur lors de la lecture de la playlist M3U:', error);\n          const m3uError = error instanceof Error ? error : new Error(`Échec de l'analyse de la playlist M3U: ${String(error)}`);\n          this.errorHandlers.forEach(handler => handler(m3uError));\n          throw m3uError;\n        }\n      } else {\n        console.log(`[RPlayer] Tentative de lecture directe: ${src}`);\n        this.src = src;\n        this.lastSrc = src;\n        this.isHls = false;\n\n        try {\n          await this.play();\n          console.log(`[RPlayer] Lecture directe réussie`);\n          return;\n        } catch (playError) {\n          console.error('[RPlayer] Erreur lors de la lecture directe:', playError);\n          const directError = new Error(`Échec de la lecture de la source: ${src}`);\n          this.errorHandlers.forEach(handler => handler(directError));\n          throw directError;\n        }\n      }\n    } catch (error) {\n      console.error('Error playing source', error);\n      this.errorHandlers.forEach(handler => handler(error instanceof Error ? error : new Error(String(error))));\n      throw error;\n    }\n  }\n\n  /**\n   * Load a source without automatically playing it\n   * This is useful for preloading sources or working with autoplay restrictions\n   * @param {string} src - The source URL to load\n   * @returns {Promise<void>} - A promise that resolves when the source is loaded\n   */\n  async loadSrc(src: string): Promise<void> {\n    console.log(`[RPlayer] loadSrc appelé avec: ${src}`);\n\n    // Convertir les chemins relatifs en URL absolues\n    if (src.startsWith('/') && !src.startsWith('//') && typeof window !== 'undefined') {\n      const origin = window.location.origin;\n      src = `${origin}${src}`;\n      console.log(`[RPlayer] URL relative convertie en absolue: ${src}`);\n    }\n\n    try {\n      // Stop any current playback\n      this.stop();\n\n      // Déterminer le type de source\n      const isHls = this.isHlsUrl(src);\n      const isM3u = this.isM3uUrl(src);\n\n      // Détermination du type de source pour le log\n      let sourceType = 'Direct';\n      if (isHls) sourceType = 'HLS';\n      else if (isM3u) sourceType = 'M3U standard';\n      console.log(`[RPlayer] Type de source: ${sourceType}`);\n\n      if (isHls) {\n        try {\n          // playHls est maintenant utilisé uniquement pour charger la source, sans lecture automatique\n          // Nous modifierons la fonction playHls pour accepter un paramètre autoplay\n          const hlsInstance = await playHls(this, src, undefined, false);\n          this.hls = hlsInstance;\n          this.lastSrc = src;\n          this.isHls = true;\n          return Promise.resolve();\n        } catch (error) {\n          console.error('Error initializing HLS source:', error);\n          throw error;\n        }\n      } else if (this.isM3uUrl(src)) {\n        try {\n          console.log(`[RPlayer] Attempting to load M3U standard playlist: ${src}`);\n          // Pour les playlists M3U, nous extrayons la première URL mais ne lançons pas la lecture\n          const mediaUrl = await playM3u(this, src);\n          console.log(`[RPlayer] URL extracted from M3U playlist: ${mediaUrl}`);\n\n          // Éviter les boucles infinies\n          if (mediaUrl === src) {\n            throw new Error(\"The URL extracted from the playlist is identical to the playlist URL\");\n          }\n\n          // Mettre à jour pour la traçabilité\n          this.lastSrc = src;\n\n          // Charger la source médias sans lecture automatique\n          return this.loadSrc(mediaUrl);\n        } catch (error) {\n          console.error('[RPlayer] Erreur lors du chargement de la playlist M3U:', error);\n          const m3uError = error instanceof Error ? error : new Error(`Échec de l'analyse de la playlist M3U: ${String(error)}`);\n          this.errorHandlers.forEach(handler => handler(m3uError));\n          throw m3uError;\n        }\n      } else {\n        console.log(`[RPlayer] Chargement direct sans lecture: ${src}`);\n        this.src = src;\n        this.lastSrc = src;\n        this.isHls = false;\n\n        // Ne pas lancer la lecture automatiquement\n        // Charger les métadonnées pour s'assurer que la source est bien chargée\n        return new Promise((resolve, reject) => {\n          const onLoadedMetadata = () => {\n            this.removeEventListener('loadedmetadata', onLoadedMetadata);\n            this.removeEventListener('error', onError);\n            resolve();\n          };\n\n          const onError = () => {\n            this.removeEventListener('loadedmetadata', onLoadedMetadata);\n            this.removeEventListener('error', onError);\n            const error = new Error(`Échec du chargement de la source: ${src}`);\n            this.errorHandlers.forEach(handler => handler(error));\n            reject(error);\n          };\n\n          this.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });\n          this.addEventListener('error', onError, { once: true });\n\n          // Déclencher le chargement sans lecture\n          this.load();\n        });\n      }\n    } catch (error) {\n      console.error('Error loading source', error);\n      this.errorHandlers.forEach(handler => handler(error instanceof Error ? error : new Error(String(error))));\n      throw error;\n    }\n  }\n\n  /**\n   * Stop the audio element\n   * This will pause the audio, reset the current time to 0, clean up HLS resources\n   * and reset internal state\n   */\n  stop(): void {\n    this.pause();\n    this.currentTime = 0;\n\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n\n    // Réinitialiser complètement l'état\n    this.isHls = false;\n\n    // Important: ne pas effacer lastSrc pour permettre l'affichage du dernier flux\n    // tout en indiquant que la lecture est arrêtée\n\n    this.playbackHandlers.forEach(handler => handler('stopped'));\n  }\n\n  /**\n   * Rewind the audio element by the specified number of seconds\n   * @param {number} seconds - The number of seconds to rewind\n   */\n  rewind(seconds: number): void {\n    this.currentTime = Math.max(this.currentTime - seconds, 0);\n  }\n\n  /**\n   * Fast forward the audio element by the specified number of seconds\n   * @param {number} seconds - The number of seconds to fast forward\n   */\n  forward(seconds: number): void {\n    if (this.duration && isFinite(this.duration)) {\n      this.currentTime = Math.min(this.currentTime + seconds, this.duration);\n    } else {\n      this.currentTime += seconds;\n    }\n  }\n\n  /**\n   * Increase the volume by 10%\n   * The volume will not exceed 100%\n   */\n  upVolume(): void {\n    this.volume = Math.min(this.volume + 0.1, 1);\n    this.volume = parseFloat(this.volume.toFixed(2));\n  }\n\n  /**\n   * Decrease the volume by 10%\n   * The volume will not go below 0%\n   */\n  downVolume(): void {\n    this.volume = Math.max(this.volume - 0.1, 0);\n    this.volume = parseFloat(this.volume.toFixed(2));\n  }\n\n  /**\n   * Set the volume to a specific level\n   * @param {number} level - A value between 0 and 1\n   */\n  setVolume(level: number): void {\n    if (level < 0 || level > 1) {\n      throw new Error('Volume level must be between 0 and 1');\n    }\n\n    this.volume = parseFloat(level.toFixed(2));\n  }\n\n  /**\n   * Toggle the mute state of the audio element\n   */\n  mute(): void {\n    this.muted = !this.muted;\n  }\n\n  /**\n   * Update MediaSession metadata with current track information\n   * @param title - The title of the current track\n   * @param artist - The artist name\n   * @param album - The album name\n   */\n  updateMediaSessionMetadata(title: string = '', artist: string = 'RPlayer', album: string = 'Audio Stream'): void {\n    if ('mediaSession' in navigator) {\n      try {\n        navigator.mediaSession.metadata = new MediaMetadata({\n          title: title || this.lastSrc || 'Unknown Track',\n          artist,\n          album,\n          artwork: [\n            { src: '/images/favicon.png', sizes: '96x96', type: 'image/png' },\n            { src: '/images/icons-192.png', sizes: '192x192', type: 'image/png' }\n          ]\n        });\n        console.log(`[RPlayer] MediaSession metadata updated: ${title}`);\n      } catch (error) {\n        console.error('[RPlayer] Error updating MediaSession metadata:', error);\n      }\n    }\n  }\n\n  /**\n   * Clean up resources when the player is no longer needed\n   * This will stop any playback and release all resources\n   */\n  destroy(): void {\n    this.stop();\n\n    // Remove all event listeners\n    this.playbackHandlers.length = 0;\n    this.errorHandlers.length = 0;\n\n    // Clean up MediaSession handlers\n    if ('mediaSession' in navigator) {\n      try {\n        // Clear all action handlers\n        ['play', 'pause', 'stop', 'seekforward', 'seekbackward', 'previoustrack', 'nexttrack'].forEach(action => {\n          try {\n            navigator.mediaSession.setActionHandler(action as MediaSessionAction, null);\n          } catch (e) {\n            // Some browsers might not support all actions\n          }\n        });\n      } catch (error) {\n        console.warn('[RPlayer] Error clearing MediaSession handlers:', error);\n      }\n    }\n\n    // Clean up any other resources\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n  }\n}\n\n// Export types\nexport type RPlayerEvents = {\n  onPlay: () => void;\n  onPause: () => void;\n  onStop: () => void;\n  onError: (error: Error) => void;\n  onVolumeChange: (volume: number) => void;\n  onTimeUpdate: (time: number) => void;\n};\n\n// Export the RPlayer class\nexport default RPlayer;\n"],"names":[],"mappings":"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"}