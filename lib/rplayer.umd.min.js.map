{"version":3,"file":"rplayer.umd.min.js","sources":["../src/lib/playHls.ts","../src/lib/playM3u.ts","../src/lib/index.ts"],"sourcesContent":["// Interface pour les statistiques de lecture HLS\nexport interface HlsStats {\n  bandwidth: number;        // Estimation du débit en bits par seconde\n  droppedFrames: number;    // Nombre d'images perdues\n  bufferLength: number;     // Longueur du tampon en secondes\n  currentLevel: number;     // Niveau de qualité actuel\n  totalLevels: number;      // Nombre total de niveaux de qualité disponibles\n  loadLatency: number;      // Latence de chargement en millisecondes\n}\n\n// Type pour les callbacks de statistiques\nexport type StatsCallback = (stats: HlsStats) => void;\n\n/**\n * Play or load the provided HLS source with dynamic loading of hls.js if needed.\n * @param {HTMLAudioElement} audioElement - The audio element to play the HLS stream.\n * @param {string} src - The source URL of the HLS stream.\n * @param {StatsCallback} [onStatsUpdate] - Optional callback function for streaming statistics updates\n * @param {boolean} [autoplay=true] - Whether to start playback automatically\n * @returns {Promise<any|null>} - The Hls instance if created, or null if native HLS is used\n */\nexport async function playHls(\n  audioElement: HTMLAudioElement,\n  src: string,\n  onStatsUpdate?: StatsCallback,\n  autoplay: boolean = true\n): Promise<any | null> {\n  // First check if we can use native HLS support (Safari/iOS)\n  if (audioElement.canPlayType('application/vnd.apple.mpegurl')) {\n    console.log('Using native HLS support');\n    audioElement.src = src;\n\n    return new Promise((resolve) => {\n      audioElement.addEventListener('loadedmetadata', () => {\n        if (autoplay) {\n          const playPromise = audioElement.play();\n\n          if (playPromise !== undefined) {\n            playPromise.catch(error => {\n              console.warn('Auto-play was prevented, user interaction may be needed', error);\n            });\n          }\n        }\n\n        resolve(null); // Return null as we're using native HLS support\n      }, { once: true });\n    });\n  }\n\n  // Otherwise, try to dynamically import hls.js\n  try {\n    const { default: Hls } = await import('hls.js');\n\n    // If HLS.js is supported, use it\n    if (Hls.isSupported()) {\n      // Create a new HLS instance with improved error recovery\n      const hls = new Hls({\n        // Add some configuration for better performance and reliability\n        maxBufferLength: 30,\n        maxMaxBufferLength: 60,\n        liveSyncDurationCount: 3,\n        enableWorker: true,\n        lowLatencyMode: true,\n        // Error recovery settings\n        fragLoadingMaxRetry: 5,\n        manifestLoadingMaxRetry: 5,\n        levelLoadingMaxRetry: 5\n      });\n\n      // Setup error handling\n      hls.on(Hls.Events.ERROR, (event, data) => {\n        if (data.fatal) {\n          switch (data.type) {\n            case Hls.ErrorTypes.NETWORK_ERROR:\n              // Try to recover network error\n              console.warn('Network error encountered, trying to recover', data);\n              hls.startLoad();\n              break;\n            case Hls.ErrorTypes.MEDIA_ERROR:\n              // Try to recover media error\n              console.warn('Media error encountered, trying to recover', data);\n              hls.recoverMediaError();\n              break;\n            default:\n              // Cannot recover from other fatal errors\n              console.error('Fatal error encountered, cannot recover', data);\n              break;\n          }\n        }\n      });\n\n      // Set up stats monitoring if callback is provided\n      if (onStatsUpdate) {\n        const statsInterval = 3000; // Update stats every 3 seconds\n        const statsTimer = setInterval(() => {\n          if (hls) {\n            // Calculate buffer length\n            let bufferLength = 0;\n            if (hls.media && hls.media.buffered.length > 0) {\n              bufferLength = hls.media.buffered.end(hls.media.buffered.length - 1) - hls.media.currentTime;\n            }\n\n            const hlsStats: HlsStats = {\n              bandwidth: hls.bandwidthEstimate,\n              droppedFrames: 0, // Need to calculate from media element if needed\n              bufferLength: bufferLength,\n              currentLevel: hls.currentLevel,\n              totalLevels: hls.levels ? hls.levels.length : 0,\n              loadLatency: 0  // Hls.js v1.6.1 doesn't expose this directly through typed properties\n            };\n\n            onStatsUpdate(hlsStats);\n          }\n        }, statsInterval);\n\n        // Clean up the timer when media is detached\n        hls.on(Hls.Events.MEDIA_DETACHING, () => {\n          clearInterval(statsTimer);\n        });\n      }\n\n      // Load the source and attach to audio element\n      hls.loadSource(src);\n      hls.attachMedia(audioElement as HTMLVideoElement);\n\n      // Start playback when manifest is parsed (if autoplay is enabled)\n      hls.on(Hls.Events.MANIFEST_PARSED, () => {\n        if (autoplay) {\n          const playPromise = audioElement.play();\n\n          if (playPromise !== undefined) {\n            playPromise.catch(error => {\n              console.warn('Auto-play was prevented, user interaction may be needed', error);\n            });\n          }\n        }\n      });\n\n      return hls;\n    } else {\n      throw new Error('HLS.js is not supported in this browser');\n    }\n  } catch (error) {\n    console.error('Failed to load or initialize hls.js:', error);\n    throw new Error('Failed to load or initialize HLS support: ' + (error instanceof Error ? error.message : String(error)));\n  }\n}\n\n","import { playHls } from './playHls.js';\n\n/**\n * Interface for track information in M3U playlists\n */\nexport interface M3UTrackInfo {\n  url: string;\n  title: string;\n}\n\n/**\n * Function to process standard M3U playlists (non-HLS)\n * This function downloads and parses an M3U playlist\n * @param player - The RPlayer instance to use for playback\n * @param url - The URL of the M3U playlist\n * @returns Promise that resolves with the first track URL and title when playback starts or rejects on error\n */\nexport async function playM3u(player: HTMLAudioElement, url: string): Promise<string> {\n  try {\n    console.log(`Fetching M3U playlist from: ${url}`);\n\n    // Spécial pour les fichiers locaux (peut-être que l'URL est déjà un chemin local ou relatif)\n    if (!url.startsWith('http://') && !url.startsWith('https://')) {\n      // C'est une URL locale, construisons une URL absolue\n      const origin = window.location.origin;\n      // Gestion spéciale pour les chemins absolus et relatifs\n      if (url.startsWith('/')) {\n        url = origin + url;\n      } else {\n        // Pour les chemins relatifs comme './playlist.m3u' ou 'playlist.m3u'\n        url = origin + '/' + url.replace(/^\\.\\//, '');\n      }\n      console.log(`Local file detected, using absolute URL: ${url}`);\n    }\n\n    // Récupérer le contenu de la playlist avec un délai d'attente de 10 secondes\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000);\n\n    try {\n      // Ajout des options pour éviter les problèmes CORS\n      const response = await fetch(url, {\n        signal: controller.signal,\n        mode: 'cors',\n        credentials: 'same-origin'\n      });\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch M3U playlist: ${response.status}`);\n      }\n\n      const content = await response.text();\n      console.log(`M3U content fetched, size: ${content.length} bytes`);\n\n      // Parser le contenu de la playlist\n      const lines = content.split('\\n');\n      const mediaUrls: {url: string; title: string}[] = [];\n      let currentTitle = '';\n\n      // Extraire les URL des médias avec leurs titres\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n\n        // Ignorer les lignes vides\n        if (!line) continue;\n\n        // Traiter les métadonnées EXTINF (titres)\n        if (line.startsWith('#EXTINF:')) {\n          const titleMatch = line.match(/#EXTINF:.*,(.+)/);\n          if (titleMatch && titleMatch[1]) {\n            currentTitle = titleMatch[1].trim();\n          }\n          continue;\n        }\n\n        // Ignorer les autres commentaires et directives\n        if (line.startsWith('#')) continue;\n\n        // Si c'est une URL, l'ajouter avec son titre\n        // Vérifier si c'est une URL absolue ou relative\n        let mediaUrl = line;\n\n        // Si c'est une URL relative, la rendre absolue par rapport à l'URL de la playlist\n        if (!line.match(/^(https?:\\/\\/|rtmp:\\/\\/|rtsp:\\/\\/)/i)) {\n          try {\n            const baseUrl = new URL(url);\n            const resolvedUrl = new URL(line, baseUrl.href);\n            mediaUrl = resolvedUrl.href;\n          } catch (e) {\n            console.warn(`Could not resolve relative URL: ${line}`, e);\n          }\n        }\n\n        // Vérifier si l'URL semble être un flux audio (filtrer vidéo si possible)\n        // Ceci est une heuristique simple et pourrait ne pas être parfaite\n        const isLikelyAudio =\n          !mediaUrl.match(/\\.(m3u8|mp4|mkv|avi|mov|flv|wmv|ts)$/i) ||\n          mediaUrl.match(/\\.(mp3|aac|ogg|opus|wav|m4a)$/i) ||\n          mediaUrl.includes('audio') ||\n          !mediaUrl.includes('video');\n\n        if (isLikelyAudio) {\n          mediaUrls.push({\n            url: mediaUrl,\n            title: currentTitle || `Track ${mediaUrls.length + 1}`\n          });\n        }\n\n        // Réinitialiser le titre pour la prochaine entrée\n        currentTitle = '';\n      }\n\n      console.log(`Found ${mediaUrls.length} audio URLs in playlist`);\n\n      // Vérifier si des URL ont été trouvées\n      if (mediaUrls.length === 0) {\n        throw new Error('No audio URLs found in M3U playlist');\n      }\n\n      // Utiliser la première URL\n      const firstTrack = mediaUrls[0];\n      console.log(`Found first entry in M3U playlist: ${firstTrack.title} (${firstTrack.url})`);\n\n      // Store all tracks in a global variable to allow navigation between them later\n      if (typeof window !== 'undefined') {\n        (window as any).__currentM3UPlaylist = mediaUrls;\n        (window as any).__currentM3UIndex = 0;\n      }\n\n      // Store track title as a custom property on the audio element for MediaSession\n      if (player instanceof HTMLAudioElement) {\n        (player as any).__trackTitle = firstTrack.title || '';\n        (player as any).__trackSource = 'M3U Playlist';\n\n        // Update MediaSession if available\n        if ('mediaSession' in navigator) {\n          navigator.mediaSession.metadata = new MediaMetadata({\n            title: firstTrack.title || 'Unknown Track',\n            artist: 'RPlayer M3U',\n            album: 'M3U Playlist',\n            artwork: [\n              { src: '/images/favicon.png', sizes: '96x96', type: 'image/png' },\n              { src: '/images/icons-192.png', sizes: '192x192', type: 'image/png' }\n            ]\n          });\n        }\n      }\n\n      // Au lieu de jouer directement, nous renvoyons l'URL du premier élément\n      // pour que RPlayer puisse la traiter selon son type (HLS, MP3, etc.)\n      return firstTrack.url;\n    } catch (error) {\n      console.error('Error fetching M3U playlist:', error);\n      throw new Error(`Timeout or network error fetching playlist: ${error instanceof Error ? error.message : String(error)}`);\n    }\n\n  } catch (error) {\n    console.error('Error playing M3U playlist:', error);\n    throw new Error(`Failed to play M3U playlist: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n","import { playHls } from './playHls.js';\nimport { playM3u } from './playM3u.js';\n\n// Type definitions\nexport type PlaybackStatus = 'playing' | 'paused' | 'stopped';\n\n/**\n * RPlayer - An enhanced audio player with HLS support\n * @extends Audio\n */\nclass RPlayer extends Audio {\n  private hls: any | null = null;\n  private isHls: boolean = false;\n  private lastSrc: string = '';\n  private readonly errorHandlers: Array<(error: Error) => void> = [];\n  private readonly playbackHandlers: Array<(status: PlaybackStatus) => void> = [];\n\n  /**\n   * Creates a new RPlayer instance\n   * @param {string} [initialSource] - Optional initial audio source to play\n   */\n  constructor(initialSource?: string) {\n    super();\n\n    // Load volume from localStorage if available\n    this.initializeVolume();\n\n    // Set event listeners\n    this.setupEventListeners();\n\n    // Play initial source if provided after constructor finishes\n    if (initialSource) {\n      setTimeout(() => {\n        this.playSrc(initialSource).catch(error => {\n          console.error('Failed to play initial source:', error);\n        });\n      }, 0);\n    }\n  }\n\n  /**\n   * Initialize volume settings from localStorage\n   * @private\n   */\n  private initializeVolume(): void {\n    try {\n      const savedVolume = localStorage.getItem('RPlayer-volume');\n      if (savedVolume !== null) {\n        const volume = parseFloat(savedVolume);\n        if (!isNaN(volume) && volume >= 0 && volume <= 1) {\n          this.volume = volume;\n        }\n      }\n    } catch (error) {\n      console.warn('Could not retrieve volume settings from localStorage', error);\n    }\n  }\n\n  /**\n   * Set up event listeners for the audio element\n   * @private\n   */\n  private setupEventListeners(): void {\n    // Save volume to localStorage when changed\n    this.addEventListener('volumechange', () => {\n      try {\n        localStorage.setItem('RPlayer-volume', this.volume.toString());\n      } catch (error) {\n        console.warn('Could not save volume settings to localStorage', error);\n      }\n    });\n\n    // Handle errors\n    this.addEventListener('error', (event) => {\n      const error = new Error(`Media error: ${this.error?.code ?? 'unknown'}`);\n      this.errorHandlers.forEach(handler => handler(error));\n    });\n\n    // Track play/pause status\n    this.addEventListener('play', () => {\n      this.playbackHandlers.forEach(handler => handler('playing'));\n    });\n\n    this.addEventListener('pause', () => {\n      this.playbackHandlers.forEach(handler => handler('paused'));\n    });\n  }\n\n  /**\n   * Validate if the provided URL is an HLS stream.\n   * @param {string | URL} url - The URL to validate.\n   * @returns {boolean} True if the URL is an HLS stream, false otherwise.\n   * @private\n   */\n  private isHlsUrl(url: string | URL): boolean {\n    const urlStr = url.toString();\n\n    // Gestion simple pour les chemins relatifs ou les URL\n    if (urlStr.endsWith('.m3u8')) {\n      return true;\n    }\n\n    try {\n      // Pour les URL complètes, nous pouvons toujours utiliser l'objet URL\n      if (urlStr.startsWith('http://') || urlStr.startsWith('https://')) {\n        const parsedUrl = new URL(urlStr);\n        return parsedUrl.pathname.endsWith('.m3u8');\n      }\n      return false;\n    } catch (error) {\n      // Si nous ne pouvons pas construire un objet URL, vérifier simplement l'extension\n      console.warn('URL parsing failed in isHlsUrl, using fallback check:', urlStr);\n      return false;\n    }\n  }\n\n  /**\n   * Validate if the provided URL is a standard M3U playlist.\n   * @param {string | URL} url - The URL to validate.\n   * @returns {boolean} True if the URL is a standard M3U playlist, false otherwise.\n   * @private\n   */\n  private isM3uUrl(url: string | URL): boolean {\n    const urlStr = url.toString();\n\n    // Gestion simple pour les chemins relatifs ou les URL\n    if (urlStr.endsWith('.m3u') && !urlStr.endsWith('.m3u8')) {\n      return true;\n    }\n\n    try {\n      // Pour les URL complètes, nous pouvons toujours utiliser l'objet URL\n      if (urlStr.startsWith('http://') || urlStr.startsWith('https://')) {\n        const parsedUrl = new URL(urlStr);\n        return parsedUrl.pathname.endsWith('.m3u') && !parsedUrl.pathname.endsWith('.m3u8');\n      }\n      return false;\n    } catch (error) {\n      // Si nous ne pouvons pas construire un objet URL, vérifier simplement l'extension\n      console.warn('URL parsing failed in isM3uUrl, using fallback check:', urlStr);\n      return false;\n    }\n  }\n\n  /**\n   * Check if the current device is an iOS device.\n   * @returns {boolean} True if the current device is an iOS device, false otherwise.\n   * @readonly\n   */\n  get isIOS(): boolean {\n    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n  }\n\n  /**\n   * Validate if the current source is an HLS stream.\n   * @returns {boolean} True if the current source is an HLS stream, false otherwise.\n   * @readonly\n   */\n  get isHlsjs(): boolean {\n    return this.isHls;\n  }\n\n  /**\n   * Check if the audio element is currently playing.\n   * @returns {boolean} True if the audio element is playing, false otherwise.\n   * @readonly\n   */\n  get isPlaying(): boolean {\n    return !this.paused;\n  }\n\n  /**\n   * Get the current source URL of the audio element.\n   * @returns {string} The current source URL of the audio element.\n   * @readonly\n   */\n  get url(): string {\n    return this.lastSrc;\n  }\n\n  /**\n   * Register a handler for playback status changes\n   * @param {function} handler - The function to call when playback status changes\n   */\n  onPlaybackStatusChange(handler: (status: 'playing' | 'paused' | 'stopped') => void): void {\n    this.playbackHandlers.push(handler);\n  }\n\n  /**\n   * Register a handler for errors\n   * @param {function} handler - The function to call when an error occurs\n   */\n  onError(handler: (error: Error) => void): void {\n    this.errorHandlers.push(handler);\n  }\n\n  /**\n   * Remove a previously registered playback status handler\n   * @param {function} handler - The handler to remove\n   */\n  removePlaybackStatusHandler(handler: (status: 'playing' | 'paused' | 'stopped') => void): void {\n    const index = this.playbackHandlers.indexOf(handler);\n    if (index !== -1) {\n      this.playbackHandlers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Remove a previously registered error handler\n   * @param {function} handler - The handler to remove\n   */\n  removeErrorHandler(handler: (error: Error) => void): void {\n    const index = this.errorHandlers.indexOf(handler);\n    if (index !== -1) {\n      this.errorHandlers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Play the provided audio source\n   * @param {string} src - The source URL of the audio stream\n   * @returns {Promise<void>} - A promise that resolves when playback has started or rejects on error\n   */\n  async playSrc(src: string): Promise<void> {\n    console.log(`[RPlayer] playSrc appelé avec: ${src}`);\n\n    // Convertir les chemins relatifs en URL absolues\n    if (src.startsWith('/') && !src.startsWith('//') && typeof window !== 'undefined') {\n      const origin = window.location.origin;\n      src = `${origin}${src}`;\n      console.log(`[RPlayer] URL relative convertie en absolue: ${src}`);\n    }\n\n    // Don't reload if it's the same source and just paused\n    if (this.lastSrc === src && this.paused && this.currentTime > 0) {\n      try {\n        console.log(`[RPlayer] Même source détectée, reprise de la lecture: ${src}`);\n        await this.play();\n        return;\n      } catch (error) {\n        // If there's an error playing, try to reload the source\n        console.warn('[RPlayer] Erreur lors de la reprise de la lecture, tentative de rechargement', error);\n      }\n    }\n\n    try {\n      // Stop any current playback\n      this.stop();\n\n      // Déterminer le type de source\n      const isHls = this.isHlsUrl(src);\n      const isM3u = this.isM3uUrl(src);\n      console.log(`[RPlayer] Type de source: ${isHls ? 'HLS' : isM3u ? 'M3U standard' : 'Direct'}`);\n\n      // Détermination du type de source pour le log\n      let sourceType = 'Direct';\n      if (isHls) sourceType = 'HLS';\n      else if (isM3u) sourceType = 'M3U standard';\n      console.log(`[RPlayer] Type de source: ${sourceType}`);\n\n      if (isHls) {\n        try {\n          // playHls est désormais asynchrone et retourne une promesse\n          const hlsInstance = await playHls(this, src);\n          this.hls = hlsInstance;\n          this.lastSrc = src;\n          this.isHls = true;\n\n          // Return a promise that resolves when playback starts or rejects on error\n          return new Promise((resolve, reject) => {\n            const onPlay = () => {\n              this.removeEventListener('playing', onPlay);\n              this.removeEventListener('error', onError);\n              resolve();\n            };\n\n            const onError = () => {\n              this.removeEventListener('playing', onPlay);\n              this.removeEventListener('error', onError);\n              reject(new Error(`Failed to load HLS source: ${src}`));\n            };\n\n            // Si playHls a déjà commencé la lecture (support natif), résoudre immédiatement\n            if (!this.paused) {\n              resolve();\n            } else {\n              this.addEventListener('playing', onPlay);\n              this.addEventListener('error', onError);\n            }\n          });\n        } catch (error) {\n          console.error('Error initializing HLS playback:', error);\n          throw error;\n        }\n      }      else if (this.isM3uUrl(src)) {\n        try {\n          console.log(`[RPlayer] Attempting to play M3U standard playlist: ${src}`);\n          // For standard .m3u files\n          // playM3u now returns the URL of the first item in the playlist\n          const mediaUrl = await playM3u(this, src);\n          console.log(`[RPlayer] URL extracted from M3U playlist: ${mediaUrl}`);\n\n          // Call playSrc recursively with the media URL\n          // This allows automatic handling of HLS streams\n          if (mediaUrl === src) {\n            // Avoid an infinite loop if the URL is the same\n            throw new Error(\"The URL extracted from the playlist is identical to the playlist URL\");\n          }\n\n          // Update for traceability\n          this.lastSrc = src; // Keep the playlist URL as the original source\n\n          // Update MediaSession if available\n          if ('mediaSession' in navigator && navigator.mediaSession) {\n            // Try to extract station name from the URL path\n            let title = \"Radio Station\";\n            try {\n              // Extract file name from URL and clean it up\n              const urlObj = new URL(mediaUrl);\n              const pathParts = urlObj.pathname.split('/');\n              const fileName = pathParts[pathParts.length - 1];\n              if (fileName) {\n                // Remove extension and replace underscores/hyphens with spaces\n                title = fileName.replace(/\\.(mp3|aac|ogg|m4a|wav)$/i, '')\n                               .replace(/[_-]/g, ' ');\n              }\n            } catch (e) {\n              console.warn('Failed to extract title from URL:', e);\n            }\n\n            navigator.mediaSession.metadata = new MediaMetadata({\n              title: title,\n              artist: 'RPlayer M3U',\n              album: 'M3U Playlist',\n              artwork: [\n                { src: '/images/favicon.png', sizes: '96x96', type: 'image/png' },\n                { src: '/images/icons-192.png', sizes: '192x192', type: 'image/png' }\n              ]\n            });\n          }\n\n          // Redirect to the media URL\n          console.log(`[RPlayer] Redirecting to: ${mediaUrl}`);\n          return this.playSrc(mediaUrl);\n        } catch (error) {\n          console.error('[RPlayer] Erreur lors de la lecture de la playlist M3U:', error);\n          const m3uError = error instanceof Error ? error : new Error(`Échec de l'analyse de la playlist M3U: ${String(error)}`);\n          this.errorHandlers.forEach(handler => handler(m3uError));\n          throw m3uError;\n        }\n      } else {\n        console.log(`[RPlayer] Tentative de lecture directe: ${src}`);\n        this.src = src;\n        this.lastSrc = src;\n        this.isHls = false;\n\n        try {\n          await this.play();\n          console.log(`[RPlayer] Lecture directe réussie`);\n          return;\n        } catch (playError) {\n          console.error('[RPlayer] Erreur lors de la lecture directe:', playError);\n          const directError = new Error(`Échec de la lecture de la source: ${src}`);\n          this.errorHandlers.forEach(handler => handler(directError));\n          throw directError;\n        }\n      }\n    } catch (error) {\n      console.error('Error playing source', error);\n      this.errorHandlers.forEach(handler => handler(error instanceof Error ? error : new Error(String(error))));\n      throw error;\n    }\n  }\n\n  /**\n   * Load a source without automatically playing it\n   * This is useful for preloading sources or working with autoplay restrictions\n   * @param {string} src - The source URL to load\n   * @returns {Promise<void>} - A promise that resolves when the source is loaded\n   */\n  async loadSrc(src: string): Promise<void> {\n    console.log(`[RPlayer] loadSrc appelé avec: ${src}`);\n\n    // Convertir les chemins relatifs en URL absolues\n    if (src.startsWith('/') && !src.startsWith('//') && typeof window !== 'undefined') {\n      const origin = window.location.origin;\n      src = `${origin}${src}`;\n      console.log(`[RPlayer] URL relative convertie en absolue: ${src}`);\n    }\n\n    try {\n      // Stop any current playback\n      this.stop();\n\n      // Déterminer le type de source\n      const isHls = this.isHlsUrl(src);\n      const isM3u = this.isM3uUrl(src);\n\n      // Détermination du type de source pour le log\n      let sourceType = 'Direct';\n      if (isHls) sourceType = 'HLS';\n      else if (isM3u) sourceType = 'M3U standard';\n      console.log(`[RPlayer] Type de source: ${sourceType}`);\n\n      if (isHls) {\n        try {\n          // playHls est maintenant utilisé uniquement pour charger la source, sans lecture automatique\n          // Nous modifierons la fonction playHls pour accepter un paramètre autoplay\n          const hlsInstance = await playHls(this, src, undefined, false);\n          this.hls = hlsInstance;\n          this.lastSrc = src;\n          this.isHls = true;\n          return Promise.resolve();\n        } catch (error) {\n          console.error('Error initializing HLS source:', error);\n          throw error;\n        }\n      } else if (this.isM3uUrl(src)) {\n        try {\n          console.log(`[RPlayer] Attempting to load M3U standard playlist: ${src}`);\n          // Pour les playlists M3U, nous extrayons la première URL mais ne lançons pas la lecture\n          const mediaUrl = await playM3u(this, src);\n          console.log(`[RPlayer] URL extracted from M3U playlist: ${mediaUrl}`);\n\n          // Éviter les boucles infinies\n          if (mediaUrl === src) {\n            throw new Error(\"The URL extracted from the playlist is identical to the playlist URL\");\n          }\n\n          // Mettre à jour pour la traçabilité\n          this.lastSrc = src;\n\n          // Charger la source médias sans lecture automatique\n          return this.loadSrc(mediaUrl);\n        } catch (error) {\n          console.error('[RPlayer] Erreur lors du chargement de la playlist M3U:', error);\n          const m3uError = error instanceof Error ? error : new Error(`Échec de l'analyse de la playlist M3U: ${String(error)}`);\n          this.errorHandlers.forEach(handler => handler(m3uError));\n          throw m3uError;\n        }\n      } else {\n        console.log(`[RPlayer] Chargement direct sans lecture: ${src}`);\n        this.src = src;\n        this.lastSrc = src;\n        this.isHls = false;\n\n        // Ne pas lancer la lecture automatiquement\n        // Charger les métadonnées pour s'assurer que la source est bien chargée\n        return new Promise((resolve, reject) => {\n          const onLoadedMetadata = () => {\n            this.removeEventListener('loadedmetadata', onLoadedMetadata);\n            this.removeEventListener('error', onError);\n            resolve();\n          };\n\n          const onError = () => {\n            this.removeEventListener('loadedmetadata', onLoadedMetadata);\n            this.removeEventListener('error', onError);\n            const error = new Error(`Échec du chargement de la source: ${src}`);\n            this.errorHandlers.forEach(handler => handler(error));\n            reject(error);\n          };\n\n          this.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });\n          this.addEventListener('error', onError, { once: true });\n\n          // Déclencher le chargement sans lecture\n          this.load();\n        });\n      }\n    } catch (error) {\n      console.error('Error loading source', error);\n      this.errorHandlers.forEach(handler => handler(error instanceof Error ? error : new Error(String(error))));\n      throw error;\n    }\n  }\n\n  /**\n   * Stop the audio element\n   * This will pause the audio, reset the current time to 0, clean up HLS resources\n   * and reset internal state\n   */\n  stop(): void {\n    this.pause();\n    this.currentTime = 0;\n\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n\n    // Réinitialiser complètement l'état\n    this.isHls = false;\n\n    // Important: ne pas effacer lastSrc pour permettre l'affichage du dernier flux\n    // tout en indiquant que la lecture est arrêtée\n\n    this.playbackHandlers.forEach(handler => handler('stopped'));\n  }\n\n  /**\n   * Rewind the audio element by the specified number of seconds\n   * @param {number} seconds - The number of seconds to rewind\n   */\n  rewind(seconds: number): void {\n    this.currentTime = Math.max(this.currentTime - seconds, 0);\n  }\n\n  /**\n   * Fast forward the audio element by the specified number of seconds\n   * @param {number} seconds - The number of seconds to fast forward\n   */\n  forward(seconds: number): void {\n    if (this.duration && isFinite(this.duration)) {\n      this.currentTime = Math.min(this.currentTime + seconds, this.duration);\n    } else {\n      this.currentTime += seconds;\n    }\n  }\n\n  /**\n   * Increase the volume by 10%\n   * The volume will not exceed 100%\n   */\n  upVolume(): void {\n    this.volume = Math.min(this.volume + 0.1, 1);\n    this.volume = parseFloat(this.volume.toFixed(2));\n  }\n\n  /**\n   * Decrease the volume by 10%\n   * The volume will not go below 0%\n   */\n  downVolume(): void {\n    this.volume = Math.max(this.volume - 0.1, 0);\n    this.volume = parseFloat(this.volume.toFixed(2));\n  }\n\n  /**\n   * Set the volume to a specific level\n   * @param {number} level - A value between 0 and 1\n   */\n  setVolume(level: number): void {\n    if (level < 0 || level > 1) {\n      throw new Error('Volume level must be between 0 and 1');\n    }\n\n    this.volume = parseFloat(level.toFixed(2));\n  }\n\n  /**\n   * Toggle the mute state of the audio element\n   */\n  mute(): void {\n    this.muted = !this.muted;\n  }\n\n  /**\n   * Update MediaSession metadata with current track information\n   * @param title - The title of the current track\n   * @param artist - The artist name\n   * @param album - The album name\n   */\n  updateMediaSessionMetadata(title: string = '', artist: string = 'RPlayer', album: string = 'Audio Stream'): void {\n    if ('mediaSession' in navigator) {\n      try {\n        navigator.mediaSession.metadata = new MediaMetadata({\n          title: title || this.lastSrc || 'Unknown Track',\n          artist,\n          album,\n          artwork: [\n            { src: '/images/favicon.png', sizes: '96x96', type: 'image/png' },\n            { src: '/images/icons-192.png', sizes: '192x192', type: 'image/png' }\n          ]\n        });\n        console.log(`[RPlayer] MediaSession metadata updated: ${title}`);\n      } catch (error) {\n        console.error('[RPlayer] Error updating MediaSession metadata:', error);\n      }\n    }\n  }\n\n  /**\n   * Clean up resources when the player is no longer needed\n   * This will stop any playback and release all resources\n   */\n  destroy(): void {\n    this.stop();\n\n    // Remove all event listeners\n    this.playbackHandlers.length = 0;\n    this.errorHandlers.length = 0;\n\n    // Clean up MediaSession handlers\n    if ('mediaSession' in navigator) {\n      try {\n        // Clear all action handlers\n        ['play', 'pause', 'stop', 'seekforward', 'seekbackward', 'previoustrack', 'nexttrack'].forEach(action => {\n          try {\n            navigator.mediaSession.setActionHandler(action as MediaSessionAction, null);\n          } catch (e) {\n            // Some browsers might not support all actions\n          }\n        });\n      } catch (error) {\n        console.warn('[RPlayer] Error clearing MediaSession handlers:', error);\n      }\n    }\n\n    // Clean up any other resources\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n  }\n}\n\n// Export types\nexport type RPlayerEvents = {\n  onPlay: () => void;\n  onPause: () => void;\n  onStop: () => void;\n  onError: (error: Error) => void;\n  onVolumeChange: (volume: number) => void;\n  onTimeUpdate: (time: number) => void;\n};\n\n// Export the RPlayer class\nexport default RPlayer;\n"],"names":["playHls","audioElement","src","onStatsUpdate","autoplay","resolve","playPromise","error","Hls","hls","event","data","playM3u","player","url","origin","controller","timeoutId","response","content","lines","mediaUrls","currentTitle","i","line","titleMatch","mediaUrl","baseUrl","e","firstTrack","RPlayer","initialSource","savedVolume","volume","handler","urlStr","parsedUrl","index","isHls","isM3u","sourceType","hlsInstance","reject","onPlay","onError","title","pathParts","fileName","m3uError","playError","directError","onLoadedMetadata","seconds","level","artist","album","action"],"mappings":"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"}